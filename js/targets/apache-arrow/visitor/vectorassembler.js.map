{"version":3,"sources":["visitor/vectorassembler.ts"],"names":[],"mappings":"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","file":"vectorassembler.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from '../data';\r\nimport { Vector } from '../vector';\r\nimport { Visitor } from '../visitor';\r\nimport { Type, UnionMode } from '../enum';\r\nimport { RecordBatch } from '../recordbatch';\r\nimport { VectorType as V } from '../interfaces';\r\nimport { rebaseValueOffsets } from '../util/buffer';\r\nimport { packBools, truncateBitmap } from '../util/bit';\r\nimport { selectVectorChildrenArgs } from '../util/args';\r\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message';\r\nimport {\r\n    DataType, Dictionary,\r\n    Float, Int, Date_, Interval, Time, Timestamp, Union,\r\n    Bool, Null, Utf8, Binary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct,\r\n} from '../type';\r\n\r\n/** @ignore */\r\nexport interface VectorAssembler extends Visitor {\r\n    visit<T extends Vector>(node: T): this;\r\n    visitMany<T extends Vector>(nodes: T[]): this[];\r\n    getVisitFn<T extends Type>(node: T): (vector: V<T>) => this;\r\n    getVisitFn<T extends DataType>(node: V<T> | Data<T> | T): (vector: V<T>) => this;\r\n\r\n    visitBool                 <T extends Bool>            (vector: V<T>): this;\r\n    visitInt                  <T extends Int>             (vector: V<T>): this;\r\n    visitFloat                <T extends Float>           (vector: V<T>): this;\r\n    visitUtf8                 <T extends Utf8>            (vector: V<T>): this;\r\n    visitBinary               <T extends Binary>          (vector: V<T>): this;\r\n    visitFixedSizeBinary      <T extends FixedSizeBinary> (vector: V<T>): this;\r\n    visitDate                 <T extends Date_>           (vector: V<T>): this;\r\n    visitTimestamp            <T extends Timestamp>       (vector: V<T>): this;\r\n    visitTime                 <T extends Time>            (vector: V<T>): this;\r\n    visitDecimal              <T extends Decimal>         (vector: V<T>): this;\r\n    visitList                 <T extends List>            (vector: V<T>): this;\r\n    visitStruct               <T extends Struct>          (vector: V<T>): this;\r\n    visitUnion                <T extends Union>           (vector: V<T>): this;\r\n    visitInterval             <T extends Interval>        (vector: V<T>): this;\r\n    visitFixedSizeList        <T extends FixedSizeList>   (vector: V<T>): this;\r\n    visitMap                  <T extends Map_>            (vector: V<T>): this;\r\n}\r\n\r\n/** @ignore */\r\nexport class VectorAssembler extends Visitor {\r\n\r\n    /** @nocollapse */\r\n    public static assemble<T extends Vector | RecordBatch>(...args: (T | T[])[]) {\r\n        const assembler = new VectorAssembler();\r\n        const vectorChildren = selectVectorChildrenArgs(RecordBatch, args);\r\n        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);\r\n        return assembleResult;\r\n    }\r\n\r\n    private constructor() { super(); }\r\n\r\n    public visit<T extends Vector>(vector: T): this {\r\n        if (!DataType.isDictionary(vector.type)) {\r\n            const { data, length, nullCount } = vector;\r\n            if (length > 2147483647) {\r\n                /* istanbul ignore next */\r\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\r\n            }\r\n            if (!DataType.isNull(vector.type)) {\r\n                addBuffer.call(this, nullCount <= 0\r\n                    ? new Uint8Array(0) // placeholder validity buffer\r\n                    : truncateBitmap(data.offset, length, data.nullBitmap)\r\n                );\r\n            }\r\n            this.nodes.push(new FieldNode(length, nullCount));\r\n        }\r\n        return super.visit(vector);\r\n    }\r\n\r\n    public visitNull<T extends Null>(_nullV: V<T>) {\r\n        return this;\r\n    }\r\n    public visitDictionary<T extends Dictionary>(vector: V<T>) {\r\n        // Assemble the indices here, Dictionary assembled separately.\r\n        return this.visit(vector.indices);\r\n    }\r\n\r\n    public get nodes() { return this._nodes; }\r\n    public get buffers() { return this._buffers; }\r\n    public get byteLength() { return this._byteLength; }\r\n    public get bufferRegions() { return this._bufferRegions; }\r\n\r\n    protected _byteLength = 0;\r\n    protected _nodes: FieldNode[] = [];\r\n    protected _buffers: ArrayBufferView[] = [];\r\n    protected _bufferRegions: BufferRegion[] = [];\r\n}\r\n\r\n/** @ignore */\r\nfunction addBuffer(this: VectorAssembler, values: ArrayBufferView) {\r\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\r\n    this.buffers.push(values);\r\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\r\n    this._byteLength += byteLength;\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleUnion<T extends Union>(this: VectorAssembler, vector: V<T>) {\r\n    const { type, length, typeIds, valueOffsets } = vector;\r\n    // All Union Vectors have a typeIds buffer\r\n    addBuffer.call(this, typeIds);\r\n    // If this is a Sparse Union, treat it like all other Nested types\r\n    if (type.mode === UnionMode.Sparse) {\r\n        return assembleNestedVector.call(this, vector);\r\n    } else if (type.mode === UnionMode.Dense) {\r\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\r\n        if (vector.offset <= 0) {\r\n            // If the Vector hasn't been sliced, write the existing valueOffsets\r\n            addBuffer.call(this, valueOffsets);\r\n            // We can treat this like all other Nested types\r\n            return assembleNestedVector.call(this, vector);\r\n        } else {\r\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\r\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\r\n            // Union typeIds are not necessary 0-indexed\r\n            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\r\n            const childLengths = new Int32Array(maxChildTypeId + 1);\r\n            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\r\n            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\r\n            const shiftedOffsets = new Int32Array(length);\r\n            // If we have a non-zero offset, then the value offsets do not start at\r\n            // zero. We must a) create a new offsets array with shifted offsets and\r\n            // b) slice the values array accordingly\r\n            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\r\n            for (let typeId, shift, index = -1; ++index < length;) {\r\n                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\r\n                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];\r\n                }\r\n                shiftedOffsets[index] = unshiftedOffsets[index] - shift;\r\n                ++childLengths[typeId];\r\n            }\r\n            addBuffer.call(this, shiftedOffsets);\r\n            // Slice and visit children accordingly\r\n            for (let child: Vector | null, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\r\n                if (child = vector.getChildAt(childIndex)) {\r\n                    const typeId = type.typeIds[childIndex];\r\n                    const childLength = Math.min(length, childLengths[typeId]);\r\n                    this.visit(child.slice(childOffsets[typeId], childLength));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleBoolVector<T extends Bool>(this: VectorAssembler, vector: V<T>) {\r\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\r\n    let values: Uint8Array;\r\n    if (vector.nullCount >= vector.length) {\r\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\r\n        return addBuffer.call(this, new Uint8Array(0));\r\n    } else if ((values = vector.values) instanceof Uint8Array) {\r\n        // If values is already a Uint8Array, slice the bitmap (fast path)\r\n        return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));\r\n    }\r\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\r\n    // values as bools and re-pack them into a Uint8Array. This code isn't\r\n    // reachable unless you're trying to manipulate the Data internals,\r\n    // we we're only doing this for safety.\r\n    /* istanbul ignore next */\r\n    return addBuffer.call(this, packBools(vector));\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleFlatVector<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval>(this: VectorAssembler, vector: V<T>) {\r\n    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleFlatListVector<T extends Utf8 | Binary>(this: VectorAssembler, vector: V<T>) {\r\n    const { length, values, valueOffsets } = vector;\r\n    const firstOffset = valueOffsets[0];\r\n    const lastOffset = valueOffsets[length];\r\n    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\r\n    // Push in the order FlatList types read their buffers\r\n    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\r\n    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleListVector<T extends Map_ | List | FixedSizeList>(this: VectorAssembler, vector: V<T>) {\r\n    const { length, valueOffsets } = vector;\r\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\r\n    if (valueOffsets) {\r\n        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\r\n    }\r\n    // Then insert the List's values child\r\n    return this.visit(vector.getChildAt(0)!);\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleNestedVector<T extends Struct | Union>(this: VectorAssembler, vector: V<T>) {\r\n    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)!).filter(Boolean))[0];\r\n}\r\n\r\nVectorAssembler.prototype.visitBool            =     assembleBoolVector;\r\nVectorAssembler.prototype.visitInt             =     assembleFlatVector;\r\nVectorAssembler.prototype.visitFloat           =     assembleFlatVector;\r\nVectorAssembler.prototype.visitUtf8            = assembleFlatListVector;\r\nVectorAssembler.prototype.visitBinary          = assembleFlatListVector;\r\nVectorAssembler.prototype.visitFixedSizeBinary =     assembleFlatVector;\r\nVectorAssembler.prototype.visitDate            =     assembleFlatVector;\r\nVectorAssembler.prototype.visitTimestamp       =     assembleFlatVector;\r\nVectorAssembler.prototype.visitTime            =     assembleFlatVector;\r\nVectorAssembler.prototype.visitDecimal         =     assembleFlatVector;\r\nVectorAssembler.prototype.visitList            =     assembleListVector;\r\nVectorAssembler.prototype.visitStruct          =   assembleNestedVector;\r\nVectorAssembler.prototype.visitUnion           =          assembleUnion;\r\nVectorAssembler.prototype.visitInterval        =     assembleFlatVector;\r\nVectorAssembler.prototype.visitFixedSizeList   =     assembleListVector;\r\nVectorAssembler.prototype.visitMap             =     assembleListVector;\r\n"]}