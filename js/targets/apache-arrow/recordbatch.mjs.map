{"version":3,"sources":["recordbatch.ts"],"names":[],"mappings":"AAAA,6DAA6D;AAC7D,+DAA+D;AAC/D,wDAAwD;AACxD,6DAA6D;AAC7D,oDAAoD;AACpD,6DAA6D;AAC7D,6DAA6D;AAC7D,EAAE;AACF,+CAA+C;AAC/C,EAAE;AACF,6DAA6D;AAC7D,8DAA8D;AAC9D,yDAAyD;AACzD,4DAA4D;AAC5D,0DAA0D;AAC1D,qBAAqB;AAErB,OAAO,EAAE,IAAI,EAAE,MAAM,QAAQ,CAAC;AAC9B,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,MAAM,EAAS,MAAM,UAAU,CAAC;AACzC,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAC;AAC3C,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAC9C,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAc,MAAM,QAAQ,CAAC;AACtD,OAAO,EAAE,oBAAoB,EAAE,MAAM,oBAAoB,CAAC;AAE1D,OAAO,EAAE,YAAY,EAAmD,MAAM,gBAAgB,CAAC;AAY/F,MAAM,OAAO,WACT,SAAQ,YAAe;IA6BvB,YAAY,GAAG,IAAW;QACtB,IAAI,IAAqB,CAAC;QAC1B,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC,CAAc,CAAC;QAClC,IAAI,QAA8B,CAAC;QACnC,IAAI,IAAI,CAAC,CAAC,CAAC,YAAY,IAAI,EAAE;YACzB,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,GAAI,IAAsD,CAAC;SAChF;aAAM;YACH,MAAM,MAAM,GAAG,MAAM,CAAC,MAA6B,CAAC;YACpD,MAAM,CAAC,EAAE,MAAM,EAAE,SAAS,CAAC,GAAG,IAAyC,CAAC;YACxE,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,MAAM,CAAI,MAAM,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;SAC5E;QACD,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IAC1B,CAAC;IAnCD,kBAAkB;IACX,MAAM,CAAC,IAAI,CAA2D,OAA6F;QACtK,IAAI,UAAU,CAAgC,OAAO,CAAC,QAAQ,CAAC,CAAC,EAAE;YAC9D,OAAO,KAAK,CAAC,IAAI,CAAC,OAAiD,CAAC,CAAC;SACxE;QACD,OAAO,KAAK,CAAC,IAAI,CAAC,OAAsD,CAAC,CAAC;IAC9E,CAAC;IAID,kBAAkB;IACX,MAAM,CAAC,GAAG,CAA8C,GAAG,IAAW;QACzE,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,eAAe,CAAI,IAAI,CAAC,CAAC;QAC1C,MAAM,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAA2B,EAAE,CAAC,CAAC,YAAY,MAAM,CAAC,CAAC;QAC1E,OAAO,IAAI,WAAW,CAAC,GAAG,oBAAoB,CAAC,IAAI,MAAM,CAAI,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC;IAsBM,KAAK,CAAC,IAAqB,EAAE,QAAQ,GAAG,IAAI,CAAC,SAAS;QACzD,OAAO,IAAI,WAAW,CAAI,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC5D,CAAC;IAEM,MAAM,CAAC,GAAG,MAA2B;QACxC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,MAAM,CAAC,CAAC;QACvE,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,IAAI,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACtF,CAAC;IAED,IAAW,MAAM,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAC5C,IAAW,OAAO,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAC3D,IAAW,YAAY;QACnB,OAAO,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,aAAa,GAAG,mBAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1F,CAAC;IAEM,MAAM,CAA0B,GAAG,WAAgB;QACtD,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAS,EAAE,CAAC,CAAC,EAAE,IAAI,GAAG,EAAa,CAAC,CAAC;QACzG,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,WAAW,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACjH,CAAC;IACM,QAAQ,CAA6B,GAAG,aAAuB;QAClE,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,aAAa,CAAC,CAAC;QACvD,MAAM,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACnF,OAAO,IAAI,WAAW,CAAuB,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACjF,CAAC;CACJ;AAED;;;;;;;GAOG;AACH,+BAA+B;AAC/B,MAAM,OAAO,oCAAkF,SAAQ,WAAc;IACjH,YAAY,MAAiB;QACzB,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1E,CAAC;CACJ;AAED,cAAc;AACd,MAAM,mBAAoB,SAAQ,OAAO;IAAzC;;QACW,iBAAY,GAAG,IAAI,GAAG,EAAkB,CAAC;IAsBpD,CAAC;IArBU,MAAM,CAAC,OAAO,CAAwB,KAAQ;QACjD,OAAO,IAAI,mBAAmB,EAAE,CAAC,KAAK,CAClC,KAAK,CAAC,IAAI,EAAE,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAC9C,CAAC,YAAY,CAAC;IACnB,CAAC;IACM,KAAK,CAAC,IAAU,EAAE,IAAc;QACnC,IAAI,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;YAC7B,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SAC3C;aAAM;YACH,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAChC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;SACjD;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;IACM,eAAe,CAAC,IAAU,EAAE,IAAgB;QAC/C,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QACnC,IAAI,UAAU,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YACrC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;SAC9C;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;CACJ","file":"recordbatch.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from './data';\r\nimport { Table } from './table';\r\nimport { Vector } from './vector';\r\nimport { Visitor } from './visitor';\r\nimport { Schema, Field } from './schema';\r\nimport { isIterable } from './util/compat';\r\nimport { Chunked } from './vector/chunked';\r\nimport { selectFieldArgs } from './util/args';\r\nimport { DataType, Struct, Dictionary } from './type';\r\nimport { ensureSameLengthData } from './util/recordbatch';\r\nimport { Clonable, Sliceable, Applicative } from './vector';\r\nimport { StructVector, VectorBuilderOptions, VectorBuilderOptionsAsync } from './vector/index';\r\n\r\ntype VectorMap = { [key: string]: Vector };\r\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\r\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\r\n\r\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\r\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\r\n    slice(begin?: number, end?: number): RecordBatch<T>;\r\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\r\n}\r\n\r\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\r\n    extends StructVector<T>\r\n    implements Clonable<RecordBatch<T>>,\r\n               Sliceable<RecordBatch<T>>,\r\n               Applicative<Struct<T>, Table<T>> {\r\n\r\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull>): Table<T>;\r\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptionsAsync<Struct<T>, TNull>): Promise<Table<T>>;\r\n    /** @nocollapse */\r\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull> | VectorBuilderOptionsAsync<Struct<T>, TNull>) {\r\n        if (isIterable<(Struct<T>)['TValue'] | TNull>(options['values'])) {\r\n            return Table.from(options as VectorBuilderOptions<Struct<T>, TNull>);\r\n        }\r\n        return Table.from(options as VectorBuilderOptionsAsync<Struct<T>, TNull>);\r\n    }\r\n\r\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\r\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\r\n    /** @nocollapse */\r\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\r\n        const [fs, xs] = selectFieldArgs<T>(args);\r\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\r\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\r\n    }\r\n\r\n    protected _schema: Schema;\r\n    protected _dictionaries?: Map<number, Vector>;\r\n\r\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\r\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\r\n    constructor(...args: any[]) {\r\n        let data: Data<Struct<T>>;\r\n        let schema = args[0] as Schema<T>;\r\n        let children: Vector[] | undefined;\r\n        if (args[1] instanceof Data) {\r\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\r\n        } else {\r\n            const fields = schema.fields as Field<T[keyof T]>[];\r\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\r\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\r\n        }\r\n        super(data, children);\r\n        this._schema = schema;\r\n    }\r\n\r\n    public clone(data: Data<Struct<T>>, children = this._children) {\r\n        return new RecordBatch<T>(this._schema, data, children);\r\n    }\r\n\r\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\r\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\r\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\r\n    }\r\n\r\n    public get schema() { return this._schema; }\r\n    public get numCols() { return this._schema.fields.length; }\r\n    public get dictionaries() {\r\n        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\r\n    }\r\n\r\n    public select<K extends keyof T = any>(...columnNames: K[]) {\r\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\r\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\r\n    }\r\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\r\n        const schema = this._schema.selectAt(...columnIndices);\r\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\r\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\r\n    }\r\n}\r\n\r\n/**\r\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\r\n * implementations to differentiate between a stream with valid zero-length\r\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\r\n * @see https://github.com/apache/arrow/pull/4373\r\n * @ignore\r\n * @private\r\n */\r\n/* tslint:disable:class-name */\r\nexport class _InternalEmptyPlaceholderRecordBatch<T extends { [key: string]: DataType } = any> extends RecordBatch<T> {\r\n    constructor(schema: Schema<T>) {\r\n        super(schema, 0, schema.fields.map((f) => Data.new(f.type, 0, 0, 0)));\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nclass DictionaryCollector extends Visitor {\r\n    public dictionaries = new Map<number, Vector>();\r\n    public static collect<T extends RecordBatch>(batch: T) {\r\n        return new DictionaryCollector().visit(\r\n            batch.data, new Struct(batch.schema.fields)\r\n        ).dictionaries;\r\n    }\r\n    public visit(data: Data, type: DataType) {\r\n        if (DataType.isDictionary(type)) {\r\n            return this.visitDictionary(data, type);\r\n        } else {\r\n            data.childData.forEach((child, i) =>\r\n                this.visit(child, type.children[i].type));\r\n        }\r\n        return this;\r\n    }\r\n    public visitDictionary(data: Data, type: Dictionary) {\r\n        const dictionary = data.dictionary;\r\n        if (dictionary && dictionary.length > 0) {\r\n            this.dictionaries.set(type.id, dictionary);\r\n        }\r\n        return this;\r\n    }\r\n}\r\n"]}