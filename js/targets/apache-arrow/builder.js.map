{"version":3,"sources":["builder.ts"],"names":[],"mappings":"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","file":"builder.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Vector } from './vector';\r\nimport { BufferType } from './enum';\r\nimport { Data, Buffers } from './data';\r\nimport { createIsValidFunction } from './builder/valid';\r\nimport { BuilderType as B, VectorType as V} from './interfaces';\r\nimport { BufferBuilder, BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer';\r\nimport {\r\n    DataType, strideForType,\r\n    Float, Int, Decimal, FixedSizeBinary,\r\n    Date_, Time, Timestamp, Interval,\r\n    Utf8, Binary, List, Map_\r\n} from './type';\r\n\r\n/**\r\n * A set of options required to create a `Builder` instance for a given `DataType`.\r\n * @see {@link Builder}\r\n */\r\nexport interface BuilderOptions<T extends DataType = any, TNull = any> {\r\n    type: T;\r\n    nullValues?: TNull[] | ReadonlyArray<TNull> | null;\r\n    children?: { [key: string]: BuilderOptions; } | BuilderOptions[];\r\n}\r\n\r\n/**\r\n * A set of options to create an Iterable or AsyncIterable `Builder` transform function.\r\n * @see {@link Builder.throughIterable}\r\n * @see {@link Builder.throughAsyncIterable}\r\n */\r\n\r\nexport interface IterableBuilderOptions<T extends DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\r\n    highWaterMark?: number;\r\n    queueingStrategy?: 'bytes' | 'count';\r\n    dictionaryHashFunction?: (value: any) => string | number;\r\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\r\n}\r\n\r\n/**\r\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\r\n *\r\n * A `Builder` is responsible for writing arbitrary JavaScript values\r\n * to ArrayBuffers and/or child Builders according to the Arrow specification\r\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\r\n *\r\n * The `Builder` for each Arrow `DataType` handles converting and appending\r\n * values for a given `DataType`. The high-level {@link Builder.new `Builder.new()`} convenience\r\n * method creates the specific `Builder` subclass for the supplied `DataType`.\r\n *\r\n * Once created, `Builder` instances support both appending values to the end\r\n * of the `Builder`, and random-access writes to specific indices\r\n * (`Builder.prototype.append(value)` is a convenience method for\r\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\r\n * Builder's current length may cause the builder to grow its underlying buffers\r\n * or child Builders (if applicable) to accommodate the new values.\r\n *\r\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\r\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\r\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\r\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\r\n * an instance of `Vector<T>` instead.\r\n *\r\n * When there are no more values to write, use `Builder.prototype.finish()` to\r\n * finalize the `Builder`. This does not reset the internal state, so it is\r\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\r\n * if there are still values queued to be flushed.\r\n *\r\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\r\n * because this is when it flushes the values that have been enqueued in its internal\r\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\r\n *\r\n * ```ts\r\n * import { Builder, Utf8 } from 'apache-arrow';\r\n *\r\n * const utf8Builder = Builder.new({\r\n *     type: new Utf8(),\r\n *     nullValues: [null, 'n/a']\r\n * });\r\n *\r\n * utf8Builder\r\n *     .append('hello')\r\n *     .append('n/a')\r\n *     .append('world')\r\n *     .append(null);\r\n *\r\n * const utf8Vector = utf8Builder.finish().toVector();\r\n *\r\n * console.log(utf8Vector.toJSON());\r\n * // > [\"hello\", null, \"world\", null]\r\n * ```\r\n *\r\n * @typeparam T The `DataType` of this `Builder`.\r\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\r\n */\r\nexport abstract class Builder<T extends DataType = any, TNull = any> {\r\n\r\n    /**\r\n     * Create a `Builder` instance based on the `type` property of the supplied `options` object.\r\n     * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance\r\n     * and other optional parameters to be passed to the `Builder` subclass for the given `type`.\r\n     *\r\n     * @typeparam T The `DataType` of the `Builder` to create.\r\n     * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\r\n     * @nocollapse\r\n     */\r\n    // @ts-ignore\r\n    public static new<T extends DataType = any, TNull = any>(options: BuilderOptions<T, TNull>): B<T, TNull> {}\r\n\r\n    /** @nocollapse */\r\n    // @ts-ignore\r\n    public static throughNode<T extends DataType = any, TNull = any>(options: import('./io/node/builder').BuilderDuplexOptions<T, TNull>): import('stream').Duplex {\r\n        throw new Error(`\"throughNode\" not available in this environment`);\r\n    }\r\n    /** @nocollapse */\r\n    // @ts-ignore\r\n    public static throughDOM<T extends DataType = any, TNull = any>(options: import('./io/whatwg/builder').BuilderTransformOptions<T, TNull>): import('./io/whatwg/builder').BuilderTransform<T, TNull> {\r\n        throw new Error(`\"throughDOM\" not available in this environment`);\r\n    }\r\n\r\n    /**\r\n     * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\r\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\r\n     * the supplied `options` argument.\r\n     *\r\n     * This function returns a function that accepts an `Iterable` of values to\r\n     * transform. When called, this function returns an Iterator of `Vector<T>`.\r\n     *\r\n     * The resulting `Iterator<Vector<T>>` yields Vectors based on the\r\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\r\n     *\r\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\r\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\r\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\r\n     * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\r\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\r\n     *   reaches or exceeds the supplied `highWaterMark`.\r\n     *\r\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\r\n     * @returns A function which accepts a JavaScript `Iterable` of values to\r\n     *          write, and returns an `Iterator` that yields Vectors according\r\n     *          to the chunking semantics defined in the `options` argument.\r\n     * @nocollapse\r\n     */\r\n    public static throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\r\n        return throughIterable(options);\r\n    }\r\n\r\n    /**\r\n     * Transform an `AsyncIterable` of arbitrary JavaScript values into a\r\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\r\n     * the supplied `options` argument.\r\n     *\r\n     * This function returns a function that accepts an `AsyncIterable` of values to\r\n     * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\r\n     *\r\n     * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\r\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\r\n     *\r\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\r\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\r\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\r\n     * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\r\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\r\n     *   reaches or exceeds the supplied `highWaterMark`.\r\n     *\r\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\r\n     * @returns A function which accepts a JavaScript `AsyncIterable` of values\r\n     *          to write, and returns an `AsyncIterator` that yields Vectors\r\n     *          according to the chunking semantics defined in the `options`\r\n     *          argument.\r\n     * @nocollapse\r\n     */\r\n    public static throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\r\n        return throughAsyncIterable(options);\r\n    }\r\n\r\n    /**\r\n     * Construct a builder with the given Arrow DataType with optional null values,\r\n     * which will be interpreted as \"null\" when set or appended to the `Builder`.\r\n     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\r\n     */\r\n    constructor({ 'type': type, 'nullValues': nulls }: BuilderOptions<T, TNull>) {\r\n        this.type = type;\r\n        this.children = [];\r\n        this.nullValues = nulls;\r\n        this.stride = strideForType(type);\r\n        this._nulls = new BitmapBufferBuilder();\r\n        if (nulls && nulls.length > 0) {\r\n            this._isValid = createIsValidFunction(nulls);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Builder's `DataType` instance.\r\n     * @readonly\r\n     */\r\n    public type: T;\r\n    /**\r\n     * The number of values written to the `Builder` that haven't been flushed yet.\r\n     * @readonly\r\n     */\r\n    public length = 0;\r\n    /**\r\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\r\n     * @readonly\r\n     */\r\n    public finished = false;\r\n    /**\r\n     * The number of elements in the underlying values TypedArray that\r\n     * represent a single logical element, determined by this Builder's\r\n     * `DataType`. This is 1 for most types, but is larger when the `DataType`\r\n     * is `Int64`, `Uint64`, `Decimal`, `DateMillisecond`, certain variants of\r\n     * `Interval`, `Time`, or `Timestamp`, `FixedSizeBinary`, and `FixedSizeList`.\r\n     * @readonly\r\n     */\r\n    public readonly stride: number;\r\n    public readonly children: Builder[];\r\n    /**\r\n     * The list of null-value sentinels for this `Builder`. When one of these values\r\n     * is written to the `Builder` (either via `Builder.prototype.set()` or `Builder.prototype.append()`),\r\n     * a 1-bit is written to this Builder's underlying null BitmapBufferBuilder.\r\n     * @readonly\r\n     */\r\n    public readonly nullValues?: TNull[] | ReadonlyArray<TNull> | null;\r\n\r\n    /**\r\n     * Flush the `Builder` and return a `Vector<T>`.\r\n     * @returns {Vector<T>} A `Vector<T>` of the flushed values.\r\n     */\r\n    public toVector() { return Vector.new(this.flush()); }\r\n\r\n    public get ArrayType() { return this.type.ArrayType; }\r\n    public get nullCount() { return this._nulls.numInvalid; }\r\n    public get numChildren() { return this.children.length; }\r\n\r\n    /**\r\n     * @returns The aggregate length (in bytes) of the values that have been written.\r\n     */\r\n    public get byteLength(): number {\r\n        let size = 0;\r\n        this._offsets && (size += this._offsets.byteLength);\r\n        this._values && (size += this._values.byteLength);\r\n        this._nulls && (size += this._nulls.byteLength);\r\n        this._typeIds && (size += this._typeIds.byteLength);\r\n        return this.children.reduce((size, child) => size + child.byteLength, size);\r\n    }\r\n\r\n    /**\r\n     * @returns The aggregate number of rows that have been reserved to write new values.\r\n     */\r\n    public get reservedLength(): number {\r\n        return this._nulls.reservedLength;\r\n    }\r\n\r\n    /**\r\n     * @returns The aggregate length (in bytes) that has been reserved to write new values.\r\n     */\r\n    public get reservedByteLength(): number {\r\n        let size = 0;\r\n        this._offsets && (size += this._offsets.reservedByteLength);\r\n        this._values && (size += this._values.reservedByteLength);\r\n        this._nulls && (size += this._nulls.reservedByteLength);\r\n        this._typeIds && (size += this._typeIds.reservedByteLength);\r\n        return this.children.reduce((size, child) => size + child.reservedByteLength, size);\r\n    }\r\n\r\n    // @ts-ignore\r\n    protected _offsets: DataBufferBuilder<Int32Array>;\r\n    public get valueOffsets() { return this._offsets ? this._offsets.buffer : null; }\r\n\r\n    // @ts-ignore\r\n    protected _values: BufferBuilder<T['TArray'], any>;\r\n    public get values() { return this._values ? this._values.buffer : null; }\r\n\r\n    protected _nulls: BitmapBufferBuilder;\r\n    public get nullBitmap() { return this._nulls ? this._nulls.buffer : null; }\r\n\r\n    // @ts-ignore\r\n    protected _typeIds: DataBufferBuilder<Int8Array>;\r\n    public get typeIds() { return this._typeIds ? this._typeIds.buffer : null; }\r\n\r\n    // @ts-ignore\r\n    protected _isValid: (value: T['TValue'] | TNull) => boolean;\r\n    // @ts-ignore\r\n    protected _setValue: (inst: Builder<T>, index: number, value: T['TValue']) => void;\r\n\r\n    /**\r\n     * Appends a value (or null) to this `Builder`.\r\n     * This is equivalent to `builder.set(builder.length, value)`.\r\n     * @param {T['TValue'] | TNull } value The value to append.\r\n     */\r\n    public append(value: T['TValue'] | TNull) { return this.set(this.length, value); }\r\n\r\n    /**\r\n     * Validates whether a value is valid (true), or null (false)\r\n     * @param {T['TValue'] | TNull } value The value to compare against null the value representations\r\n     */\r\n    // @ts-ignore\r\n    public isValid(value: T['TValue'] | TNull): boolean { return this._isValid(value); }\r\n\r\n    /**\r\n     * Write a value (or null-value sentinel) at the supplied index.\r\n     * If the value matches one of the null-value representations, a 1-bit is\r\n     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\r\n     * the null `BitmapBufferBuilder`, and the value is passed to\r\n     * `Builder.prototype.setValue()`.\r\n     * @param {number} index The index of the value to write.\r\n     * @param {T['TValue'] | TNull } value The value to write at the supplied index.\r\n     * @returns {this} The updated `Builder` instance.\r\n     */\r\n    public set(index: number, value: T['TValue'] | TNull) {\r\n        if (this.setValid(index, this.isValid(value))) {\r\n            this.setValue(index, value);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Write a value to the underlying buffers at the supplied index, bypassing\r\n     * the null-value check. This is a low-level method that\r\n     * @param {number} index\r\n     * @param {T['TValue'] | TNull } value\r\n     */\r\n    // @ts-ignore\r\n    public setValue(index: number, value: T['TValue']) { this._setValue(this, index, value); }\r\n    public setValid(index: number, valid: boolean) {\r\n        this.length = this._nulls.set(index, +valid).length;\r\n        return valid;\r\n    }\r\n\r\n    // @ts-ignore\r\n    public addChild(child: Builder, name = `${this.numChildren}`) {\r\n        throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the child `Builder` at the supplied `index`, or null if no child\r\n     * exists at that index.\r\n     * @param {number} index The index of the child `Builder` to retrieve.\r\n     * @returns {Builder | null} The child Builder at the supplied index or null.\r\n     */\r\n    public getChildAt<R extends DataType = any>(index: number): Builder<R> | null {\r\n        return this.children[index] || null;\r\n    }\r\n\r\n    /**\r\n     * Commit all the values that have been written to their underlying\r\n     * ArrayBuffers, including any child Builders if applicable, and reset\r\n     * the internal `Builder` state.\r\n     * @returns A `Data<T>` of the buffers and childData representing the values written.\r\n     */\r\n    public flush() {\r\n\r\n        const buffers: any = [];\r\n        const values =  this._values;\r\n        const offsets =  this._offsets;\r\n        const typeIds =  this._typeIds;\r\n        const { length, nullCount } = this;\r\n\r\n        if (typeIds) { /* Unions */\r\n            buffers[BufferType.TYPE] = typeIds.flush(length);\r\n            // DenseUnions\r\n            offsets && (buffers[BufferType.OFFSET] = offsets.flush(length));\r\n        } else if (offsets) { /* Variable-width primitives (Binary, Utf8) and Lists */\r\n            // Binary, Utf8\r\n            values && (buffers[BufferType.DATA] = values.flush(offsets.last()));\r\n            buffers[BufferType.OFFSET] = offsets.flush(length);\r\n        } else if (values) { /* Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval) */\r\n            buffers[BufferType.DATA] = values.flush(length);\r\n        }\r\n\r\n        nullCount > 0 && (buffers[BufferType.VALIDITY] = this._nulls.flush(length));\r\n\r\n        const data = Data.new<T>(\r\n            this.type, 0, length, nullCount, buffers as Buffers<T>,\r\n            this.children.map((child) => child.flush())) as Data<T>;\r\n\r\n        this.clear();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Finalize this `Builder`, and child builders if applicable.\r\n     * @returns {this} The finalized `Builder` instance.\r\n     */\r\n    public finish() {\r\n        this.finished = true;\r\n        this.children.forEach((child) => child.finish());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\r\n     * @returns {this} The cleared `Builder` instance.\r\n     */\r\n    public clear() {\r\n        this.length = 0;\r\n        this._offsets && (this._offsets.clear());\r\n        this._values && (this._values.clear());\r\n        this._nulls && (this._nulls.clear());\r\n        this._typeIds && (this._typeIds.clear());\r\n        this.children.forEach((child) => child.clear());\r\n        return this;\r\n    }\r\n}\r\n\r\n(Builder.prototype as any).length = 1;\r\n(Builder.prototype as any).stride = 1;\r\n(Builder.prototype as any).children = null;\r\n(Builder.prototype as any).finished = false;\r\n(Builder.prototype as any).nullValues = null;\r\n(Builder.prototype as any)._isValid = () => true;\r\n\r\n/** @ignore */\r\nexport abstract class FixedWidthBuilder<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval = any, TNull = any> extends Builder<T, TNull> {\r\n    constructor(opts: BuilderOptions<T, TNull>) {\r\n        super(opts);\r\n        this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\r\n    }\r\n    public setValue(index: number, value: T['TValue']) {\r\n        const values = this._values;\r\n        values.reserve(index - values.length + 1);\r\n        return super.setValue(index, value);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nexport abstract class VariableWidthBuilder<T extends Binary | Utf8 | List | Map_, TNull = any> extends Builder<T, TNull> {\r\n    protected _pendingLength: number = 0;\r\n    protected _offsets: OffsetsBufferBuilder;\r\n    protected _pending: Map<number, any> | undefined;\r\n    constructor(opts: BuilderOptions<T, TNull>) {\r\n        super(opts);\r\n        this._offsets = new OffsetsBufferBuilder();\r\n    }\r\n    public setValue(index: number, value: T['TValue']) {\r\n        const pending = this._pending || (this._pending = new Map());\r\n        const current = pending.get(index);\r\n        current && (this._pendingLength -= current.length);\r\n        this._pendingLength += value.length;\r\n        pending.set(index, value);\r\n    }\r\n    public setValid(index: number, isValid: boolean) {\r\n        if (!super.setValid(index, isValid)) {\r\n            (this._pending || (this._pending = new Map())).set(index, undefined);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    public clear() {\r\n        this._pendingLength = 0;\r\n        this._pending = undefined;\r\n        return super.clear();\r\n    }\r\n    public flush() {\r\n        this._flush();\r\n        return super.flush();\r\n    }\r\n    public finish() {\r\n        this._flush();\r\n        return super.finish();\r\n    }\r\n    protected _flush() {\r\n        const pending = this._pending;\r\n        const pendingLength = this._pendingLength;\r\n        this._pendingLength = 0;\r\n        this._pending = undefined;\r\n        if (pending && pending.size > 0) {\r\n            this._flushPending(pending, pendingLength);\r\n        }\r\n        return this;\r\n    }\r\n    protected abstract _flushPending(pending: Map<number, any>, pendingLength: number): void;\r\n}\r\n\r\n/** @ignore */\r\ntype ThroughIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull>) => IterableIterator<V<T>>;\r\n\r\n/** @ignore */\r\nfunction throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\r\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\r\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\r\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\r\n    return function*(source: Iterable<T['TValue'] | TNull>) {\r\n        let numChunks = 0;\r\n        let builder = Builder.new(options);\r\n        for (const value of source) {\r\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\r\n                ++numChunks && (yield builder.toVector());\r\n            }\r\n        }\r\n        if (builder.finish().length > 0 || numChunks === 0) {\r\n            yield builder.toVector();\r\n        }\r\n    } as ThroughIterable<T, TNull>;\r\n}\r\n\r\n/** @ignore */\r\ntype ThroughAsyncIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) => AsyncIterableIterator<V<T>>;\r\n\r\n/** @ignore */\r\nfunction throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\r\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\r\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\r\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\r\n    return async function* (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) {\r\n        let numChunks = 0;\r\n        let builder = Builder.new(options);\r\n        for await (const value of source) {\r\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\r\n                ++numChunks && (yield builder.toVector());\r\n            }\r\n        }\r\n        if (builder.finish().length > 0 || numChunks === 0) {\r\n            yield builder.toVector();\r\n        }\r\n    } as ThroughAsyncIterable<T, TNull>;\r\n}\r\n"]}