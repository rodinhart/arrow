{"version":3,"sources":["schema.ts"],"names":[],"mappings":"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","file":"schema.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from './data';\r\nimport { Vector } from './vector';\r\nimport { DataType } from './type';\r\nimport { selectArgs } from './util/args';\r\nimport { selectFieldArgs } from './util/args';\r\nimport { instance as comparer } from './visitor/typecomparator';\r\n\r\ntype VectorMap = { [key: string]: Vector };\r\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\r\ntype ChildData<T extends { [key: string]: DataType }> = T[keyof T][] | Data<T[keyof T]>[] | Vector<T[keyof T]>[];\r\n\r\nexport class Schema<T extends { [key: string]: DataType } = any> {\r\n\r\n    public static from<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\r\n    public static from<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\r\n    public static from<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\r\n    /** @nocollapse */\r\n    public static from(...args: any[]) {\r\n        return Schema.new(args[0], args[1]);\r\n    }\r\n\r\n    public static new<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\r\n    public static new<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\r\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\r\n    /** @nocollapse */\r\n    public static new(...args: any[]) {\r\n        return new Schema(selectFieldArgs(args)[0]);\r\n    }\r\n\r\n    public readonly fields: Field<T[keyof T]>[];\r\n    public readonly metadata: Map<string, string>;\r\n    public readonly dictionaries: Map<number, DataType>;\r\n\r\n    constructor(fields: Field[] = [],\r\n                metadata?: Map<string, string> | null,\r\n                dictionaries?: Map<number, DataType> | null) {\r\n        this.fields = (fields || []) as Field<T[keyof T]>[];\r\n        this.metadata = metadata || new Map();\r\n        if (!dictionaries) {\r\n            dictionaries = generateDictionaryMap(fields);\r\n        }\r\n        this.dictionaries = dictionaries;\r\n    }\r\n    public get [Symbol.toStringTag]() { return 'Schema'; }\r\n    public toString() {\r\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\r\n    }\r\n\r\n    public compareTo(other?: Schema | null): other is Schema<T> {\r\n        return comparer.compareSchemas(this, other);\r\n    }\r\n\r\n    public select<K extends keyof T = any>(...columnNames: K[]) {\r\n        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\r\n        return new Schema<{ [P in K]: T[P] }>(this.fields.filter((f) => names[f.name]), this.metadata);\r\n    }\r\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\r\n        return new Schema<{ [key: string]: K }>(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);\r\n    }\r\n\r\n    public assign<R extends { [key: string]: DataType } = any>(schema: Schema<R>): Schema<T & R>;\r\n    public assign<R extends { [key: string]: DataType } = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\r\n    public assign<R extends { [key: string]: DataType } = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\r\n\r\n        const other = args[0] instanceof Schema ? args[0] as Schema<R>\r\n            : new Schema<R>(selectArgs<Field<R[keyof R]>>(Field, args));\r\n\r\n        const curFields = [...this.fields] as Field[];\r\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\r\n        const newFields = other.fields.filter((f2) => {\r\n            const i = curFields.findIndex((f) => f.name === f2.name);\r\n            return ~i ? (curFields[i] = f2.clone({\r\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\r\n            })) && false : true;\r\n        }) as Field[];\r\n\r\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\r\n\r\n        return new Schema<T & R>(\r\n            [...curFields, ...newFields], metadata,\r\n            new Map([...this.dictionaries, ...newDictionaries])\r\n        );\r\n    }\r\n}\r\n\r\nexport class Field<T extends DataType = any> {\r\n\r\n    public static new<T extends DataType = any>(props: { name: string | number, type: T, nullable?: boolean, metadata?: Map<string, string> | null }): Field<T>;\r\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\r\n    /** @nocollapse */\r\n    public static new<T extends DataType = any>(...args: any[]) {\r\n        let [name, type, nullable, metadata] = args;\r\n        if (args[0] && typeof args[0] === 'object') {\r\n            ({ name } = args[0]);\r\n            (type === undefined) && (type = args[0].type);\r\n            (nullable === undefined) && (nullable = args[0].nullable);\r\n            (metadata === undefined) && (metadata = args[0].metadata);\r\n        }\r\n        return new Field<T>(`${name}`, type, nullable, metadata);\r\n    }\r\n\r\n    public readonly type: T;\r\n    public readonly name: string;\r\n    public readonly nullable: boolean;\r\n    public readonly metadata: Map<string, string>;\r\n\r\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.nullable = nullable;\r\n        this.metadata = metadata || new Map();\r\n    }\r\n\r\n    public get typeId() { return this.type.typeId; }\r\n    public get [Symbol.toStringTag]() { return 'Field'; }\r\n    public toString() { return `${this.name}: ${this.type}`; }\r\n    public compareTo(other?: Field | null): other is Field<T> {\r\n        return comparer.compareField(this, other);\r\n    }\r\n    public clone<R extends DataType = T>(props: { name?: string | number, type?: R, nullable?: boolean, metadata?: Map<string, string> | null }): Field<R>;\r\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\r\n    public clone<R extends DataType = T>(...args: any[]) {\r\n        let [name, type, nullable, metadata] = args;\r\n        (!args[0] || typeof args[0] !== 'object')\r\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\r\n            : ({name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata} = args[0]);\r\n        return Field.new<R>(name, type, nullable, metadata);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\r\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\r\n}\r\n\r\n/** @ignore */\r\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\r\n\r\n    for (let i = -1, n = fields.length; ++i < n;) {\r\n        const field = fields[i];\r\n        const type = field.type;\r\n        if (DataType.isDictionary(type)) {\r\n            if (!dictionaries.has(type.id)) {\r\n                dictionaries.set(type.id, type.dictionary);\r\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\r\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\r\n            }\r\n        }\r\n        if (type.children && type.children.length > 0) {\r\n            generateDictionaryMap(type.children, dictionaries);\r\n        }\r\n    }\r\n\r\n    return dictionaries;\r\n}\r\n\r\n// Add these here so they're picked up by the externs creator\r\n// in the build, and closure-compiler doesn't minify them away\r\n(Schema.prototype as any).fields = null;\r\n(Schema.prototype as any).metadata = null;\r\n(Schema.prototype as any).dictionaries = null;\r\n\r\n(Field.prototype as any).type = null;\r\n(Field.prototype as any).name = null;\r\n(Field.prototype as any).nullable = null;\r\n(Field.prototype as any).metadata = null;\r\n"]}