{"version":3,"sources":["vector/chunked.ts"],"names":[],"mappings":"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","file":"chunked.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from '../data';\r\nimport { Field } from '../schema';\r\nimport { clampRange } from '../util/vector';\r\nimport { DataType, Dictionary } from '../type';\r\nimport { selectChunkArgs } from '../util/args';\r\nimport { DictionaryVector } from './dictionary';\r\nimport { AbstractVector, Vector } from '../vector';\r\nimport { Clonable, Sliceable, Applicative } from '../vector';\r\n\r\n/** @ignore */\r\ntype ChunkedDict<T extends DataType> = T extends Dictionary ? Vector<T['dictionary']> : null | never;\r\n/** @ignore */\r\ntype ChunkedKeys<T extends DataType> = T extends Dictionary ? Vector<T['indices']> | Chunked<T['indices']> : null | never;\r\n\r\n/** @ignore */\r\nexport type SearchContinuation<T extends Chunked> = (column: T, chunkIndex: number, valueIndex: number) => any;\r\n\r\n/** @ignore */\r\nexport class Chunked<T extends DataType = any>\r\n    extends AbstractVector<T>\r\n    implements Clonable<Chunked<T>>,\r\n               Sliceable<Chunked<T>>,\r\n               Applicative<T, Chunked<T>> {\r\n\r\n    /** @nocollapse */\r\n    public static flatten<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\r\n        return selectChunkArgs<Vector<T>>(Vector, vectors);\r\n    }\r\n\r\n    /** @nocollapse */\r\n    public static concat<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\r\n        const chunks = Chunked.flatten<T>(...vectors);\r\n        return new Chunked<T>(chunks[0].type, chunks);\r\n    }\r\n\r\n    protected _type: T;\r\n    protected _length: number;\r\n    protected _chunks: Vector<T>[];\r\n    protected _numChildren: number;\r\n    protected _children?: Chunked[];\r\n    protected _nullCount: number = -1;\r\n    protected _chunkOffsets: Uint32Array;\r\n\r\n    constructor(type: T, chunks: Vector<T>[] = [], offsets = calculateOffsets(chunks)) {\r\n        super();\r\n        this._type = type;\r\n        this._chunks = chunks;\r\n        this._chunkOffsets = offsets;\r\n        this._length = offsets[offsets.length - 1];\r\n        this._numChildren = (this._type.children || []).length;\r\n    }\r\n\r\n    public get type() { return this._type; }\r\n    public get length() { return this._length; }\r\n    public get chunks() { return this._chunks; }\r\n    public get typeId(): T['TType'] { return this._type.typeId; }\r\n    public get VectorName() { return `Chunked<${this._type}>`; }\r\n    public get data(): Data<T> {\r\n        return this._chunks[0] ? this._chunks[0].data : <any> null;\r\n    }\r\n\r\n    public get ArrayType() { return this._type.ArrayType; }\r\n    public get numChildren() { return this._numChildren; }\r\n    public get stride() { return this._chunks[0] ? this._chunks[0].stride : 1; }\r\n    public get byteLength(): number {\r\n        return this._chunks.reduce((byteLength, chunk) => byteLength + chunk.byteLength, 0);\r\n    }\r\n    public get nullCount() {\r\n        let nullCount = this._nullCount;\r\n        if (nullCount < 0) {\r\n            this._nullCount = nullCount = this._chunks.reduce((x, { nullCount }) => x + nullCount, 0);\r\n        }\r\n        return nullCount;\r\n    }\r\n\r\n    protected _indices?: ChunkedKeys<T>;\r\n    public get indices(): ChunkedKeys<T> | null {\r\n        if (DataType.isDictionary(this._type)) {\r\n            if (!this._indices) {\r\n                const chunks = (<any> this._chunks) as DictionaryVector<T, any>[];\r\n                this._indices = (chunks.length === 1\r\n                    ? chunks[0].indices\r\n                    : Chunked.concat(...chunks.map((x) => x.indices))) as ChunkedKeys<T>;\r\n            }\r\n            return this._indices;\r\n        }\r\n        return null;\r\n    }\r\n    public get dictionary(): ChunkedDict<T> | null {\r\n        if (DataType.isDictionary(this._type)) {\r\n            return this._chunks[this._chunks.length - 1].data.dictionary as ChunkedDict<T>;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public *[Symbol.iterator](): IterableIterator<T['TValue'] | null> {\r\n        for (const chunk of this._chunks) {\r\n            yield* chunk;\r\n        }\r\n    }\r\n\r\n    public clone(chunks = this._chunks): Chunked<T> {\r\n        return new Chunked(this._type, chunks);\r\n    }\r\n\r\n    public concat(...others: Vector<T>[]): Chunked<T> {\r\n        return this.clone(Chunked.flatten(this, ...others));\r\n    }\r\n\r\n    public slice(begin?: number, end?: number): Chunked<T> {\r\n        return clampRange(this, begin, end, this._sliceInternal);\r\n    }\r\n\r\n    public getChildAt<R extends DataType = any>(index: number): Chunked<R> | null {\r\n\r\n        if (index < 0 || index >= this._numChildren) { return null; }\r\n\r\n        let columns = this._children || (this._children = []);\r\n        let child: Chunked<R>, field: Field<R>, chunks: Vector<R>[];\r\n\r\n        if (child = columns[index]) { return child; }\r\n        if (field = ((this._type.children || [])[index] as Field<R>)) {\r\n            chunks = this._chunks\r\n                .map((vector) => vector.getChildAt<R>(index))\r\n                .filter((vec): vec is Vector<R> => vec != null);\r\n            if (chunks.length > 0) {\r\n                return (columns[index] = new Chunked<R>(field.type, chunks));\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public search(index: number): [number, number] | null;\r\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N): ReturnType<N>;\r\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N) {\r\n        let idx = index;\r\n        // binary search to find the child vector and value indices\r\n        let offsets = this._chunkOffsets, rhs = offsets.length - 1;\r\n        // return early if out of bounds, or if there's just one child\r\n        if (idx < 0            ) { return null; }\r\n        if (idx >= offsets[rhs]) { return null; }\r\n        if (rhs <= 1           ) { return then ? then(this, 0, idx) : [0, idx]; }\r\n        let lhs = 0, pos = 0, mid = 0;\r\n        do {\r\n            if (lhs + 1 === rhs) {\r\n                return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];\r\n            }\r\n            mid = lhs + ((rhs - lhs) / 2) | 0;\r\n            idx >= offsets[mid] ? (lhs = mid) : (rhs = mid);\r\n        } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));\r\n        return null;\r\n    }\r\n\r\n    public isValid(index: number): boolean {\r\n        return !!this.search(index, this.isValidInternal);\r\n    }\r\n\r\n    public get(index: number): T['TValue'] | null {\r\n        return this.search(index, this.getInternal);\r\n    }\r\n\r\n    public set(index: number, value: T['TValue'] | null): void {\r\n        this.search(index, ({ chunks }, i, j) => chunks[i].set(j, value));\r\n    }\r\n\r\n    public indexOf(element: T['TValue'], offset?: number): number {\r\n        if (offset && typeof offset === 'number') {\r\n            return this.search(offset, (self, i, j) => this.indexOfInternal(self, i, j, element))!;\r\n        }\r\n        return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);\r\n    }\r\n\r\n    public toArray(): T['TArray'] {\r\n        const { chunks } = this;\r\n        const n = chunks.length;\r\n        let ArrayType: any = this._type.ArrayType;\r\n        if (n <= 0) { return new ArrayType(0); }\r\n        if (n <= 1) { return chunks[0].toArray(); }\r\n        let len = 0, src = new Array(n);\r\n        for (let i = -1; ++i < n;) {\r\n            len += (src[i] = chunks[i].toArray()).length;\r\n        }\r\n        if (ArrayType !== src[0].constructor) {\r\n            ArrayType = src[0].constructor;\r\n        }\r\n        let dst = new ArrayType(len);\r\n        let set: any = ArrayType === Array ? arraySet : typedSet;\r\n        for (let i = -1, idx = 0; ++i < n;) {\r\n            idx = set(src[i], dst, idx);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    protected getInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].get(j); }\r\n    protected isValidInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].isValid(j); }\r\n    protected indexOfInternal({ _chunks }: Chunked<T>, chunkIndex: number, fromIndex: number, element: T['TValue']) {\r\n        let i = chunkIndex - 1, n = _chunks.length;\r\n        let start = fromIndex, offset = 0, found = -1;\r\n        while (++i < n) {\r\n            if (~(found = _chunks[i].indexOf(element, start))) {\r\n                return offset + found;\r\n            }\r\n            start = 0;\r\n            offset += _chunks[i].length;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    protected _sliceInternal(self: Chunked<T>, begin: number, end: number) {\r\n        const slices: Vector<T>[] = [];\r\n        const { chunks, _chunkOffsets: chunkOffsets } = self;\r\n        for (let i = -1, n = chunks.length; ++i < n;) {\r\n            const chunk = chunks[i];\r\n            const chunkLength = chunk.length;\r\n            const chunkOffset = chunkOffsets[i];\r\n            // If the child is to the right of the slice boundary, we can stop\r\n            if (chunkOffset >= end) { break; }\r\n            // If the child is to the left of of the slice boundary, exclude\r\n            if (begin >= chunkOffset + chunkLength) { continue; }\r\n            // If the child is between both left and right boundaries, include w/o slicing\r\n            if (chunkOffset >= begin && (chunkOffset + chunkLength) <= end) {\r\n                slices.push(chunk);\r\n                continue;\r\n            }\r\n            // If the child overlaps one of the slice boundaries, include that slice\r\n            const from = Math.max(0, begin - chunkOffset);\r\n            const to = Math.min(end - chunkOffset, chunkLength);\r\n            slices.push(chunk.slice(from, to) as Vector<T>);\r\n        }\r\n        return self.clone(slices);\r\n    }\r\n}\r\n\r\n/** @ignore */\r\nfunction calculateOffsets<T extends DataType>(vectors: Vector<T>[]) {\r\n    let offsets = new Uint32Array((vectors || []).length + 1);\r\n    let offset = offsets[0] = 0, length = offsets.length;\r\n    for (let index = 0; ++index < length;) {\r\n        offsets[index] = (offset += vectors[index - 1].length);\r\n    }\r\n    return offsets;\r\n}\r\n\r\n/** @ignore */\r\nconst typedSet = (src: TypedArray, dst: TypedArray, offset: number) => {\r\n    dst.set(src, offset);\r\n    return (offset + src.length);\r\n};\r\n\r\n/** @ignore */\r\nconst arraySet = (src: any[], dst: any[], offset: number) => {\r\n    let idx = offset;\r\n    for (let i = -1, n = src.length; ++i < n;) {\r\n        dst[idx++] = src[i];\r\n    }\r\n    return idx;\r\n};\r\n\r\n/** @ignore */\r\ninterface TypedArray extends ArrayBufferView {\r\n    readonly length: number;\r\n    readonly [n: number]: number;\r\n    set(array: ArrayLike<number>, offset?: number): void;\r\n}\r\n"]}